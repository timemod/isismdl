% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/IsisMdl_doc.R
\name{fill_mdl_data_solve}
\alias{fill_mdl_data_solve}
\title{\code{\link{IsisMdl}} method: Fills model data and inverse solves for starting values}
\arguments{
\item{period}{A period range object specifying the time period for the solution.
If missing, uses the model's data period obtained via \verb{$get_data_period()}.}

\item{fit_tbl}{A tibble defining the solve specifications. Must contain
the following columns:
\describe{
\item{solve_period}{Character or period object indicating when to solve}
\item{observed_variable}{Name of the variable with observed data}
\item{solve_variable}{Name of the variable to solve for (derive)}
\item{group}{(Optional) Group identifier for solving multiple variables together.
If omitted, each row is treated as a separate group}
\item{initial_guess}{(Optional) Initial guess for the solve variable. Can be
either all numeric or empty string "" in combination with numbers
between quotation marks (e.g. "0.5").
Defaults to 0.1 if not provided, "" or NULL}
}}

\item{report}{Character string controlling output verbosity. Options:
\describe{
\item{"no"}{Does not generate a report.}
\item{"period"}{Print a report per period (default).
For each period the number of replaced missing values is reported.}
\item{"minimal"}{Print a minimal report.
Only the total number of replaced missing values is reported.}
}}

\item{...}{Additional arguments passed to the \code{nleqslv} solver (e.g., \code{control},
\code{method}, \code{global}).}
}
\value{
An \code{IsisMdl} object (copy of the original model) with solved values for
the solve variables. The original model remains unchanged.
}
\description{
This method extends \code{\link{fill_mdl_data}} by both filling missing model data
and inverse solving for starting values. Like \code{\link{fill_mdl_data}}, it
calculates missing data for endogenous variables by evaluating equations in
solution order. Additionally, it solves backward to find starting values (typically
lagged variables) that would produce observed outcomes in later periods.

This method performs inverse modeling: instead of solving the model forward from
known starting values to outputs, it solves backward to find the starting values
that would produce the observed outputs. This is particularly useful for calibration
when you need to determine historical values (lags) before your main model period
begins, based on observed data in the initial period.

The method is designed for situations where:
\itemize{
\item You have observed data for certain variables in an initial period
\item You need to solve for lagged values to use as starting values
\item Exogenous variables are already known for all periods
\item You want to initialize the model properly before running forward simulations
}

Note: This method solves for starting values, not for exogenous variables.
For solving exogenous variables, use the separate \code{solve_exo} method.

The function solves the inverse problem using
numerical optimization and returns the modified model.
}
\examples{
# Simple example: solve for starting value y(2015) based on observed data
# Model: y = y(-1), obs = y + z
# z is known for all periods, obs is observed in 2016
# We solve for y(2015) so we can run the model forward from 2016

mdl_file <- tempfile(fileext = ".mdl")
writeLines("
ident y = y(-1);
ident obs = y + z;
", mdl_file)

mdl <- isis_mdl(mdl_file, period = "2015/2020", silent = TRUE)

# Create initial data: z is known, obs is observed only in 2016
library(regts)
data_init <- regts(
  matrix(c(
    NA, NA, NA, NA, NA, NA,  # y: unknown, to be solved/calculated
    5, 6, 7, 8, 9, 10,       # z: known for all periods (exogenous)
    NA, 100, NA, NA, NA, NA  # obs: observed only in 2016
  ), ncol = 3),
  names = c("y", "z", "obs"),
  period = "2015/2020"
)
mdl$init_data(data = data_init)

# Solve for y(2015) based on obs(2016) = 100
library(tibble)
fit_tbl <- tribble(
  ~solve_period, ~group, ~observed_variable, ~solve_variable, ~initial_guess,
  "2016", "A", "obs", "y", 0.1
)

mdl_copy <- mdl$copy() # Using in a later example

mdl$fill_mdl_data_solve(
  fit_tbl = fit_tbl,
  report = "no"
)

print(mdl$get_data())

# Clean up
unlink(mdl_file)

# Example with custom solver options
mdl_copy$fill_mdl_data_solve(
  fit_tbl = fit_tbl,
  report = "no",
  control = list(trace = 0, maxit = 200)
)

}
\seealso{
Related methods: \code{\link{solve}}, \code{\link{fill_mdl_data}}, \code{\link{get_dep_struct}}
\code{\link[nleqslv]{nleqslv}} for details on the numerical solver and options.
}
